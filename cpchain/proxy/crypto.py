from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature, encode_dss_signature
from cryptography.exceptions import InvalidSignature

import json


class ECCipher:

    def generate_key_pair(self):
        self.private_key = ec.generate_private_key(
                            ec.SECP384R1(),
                            default_backend()
                        )
        self.public_key = self.private_key.public_key()

    def generate_signature(self, data):
        self.data = data
        self.signature = self.private_key.sign(
                            self.data,
                            ec.ECDSA(hashes.SHA256()))

    def verify_signature(self):
        try:
            self.public_key.verify(self.signature, self.data,
                                    ec.ECDSA(hashes.SHA256()))
        except InvalidSignature:
            return False
        else:
            return True

    def load_sign_data(self, data):
        self.data = data

    def get_public_key(self):
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )

    def load_public_key(self, serialized_public):
        self.public_key = serialization.load_pem_public_key(
                                serialized_public,
                                backend=default_backend()
                            )

    def get_private_key(self, passwd=b'cpc'):
        return self.private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=
                    serialization.BestAvailableEncryption(passwd)
                )


    def load_private_key(self, serialized_private, passwd=b'cpc'):
        self.private_key = serialization.load_pem_private_key(
                    serialized_private,
                    password=passwd,
                    backend=default_backend()
                )

        # public_key is generated by private_key
        self.public_key = self.private_key.public_key()

    def decode_signature(self):
        r,s = decode_dss_signature(self.signature)
        sign = {'r': r, 's': s}
        return json.dumps(sign)

    def encode_signature(self, sign):
        sign = json.loads(sign)
        self.signature = encode_dss_signature(sign['r'], sign['s'])


